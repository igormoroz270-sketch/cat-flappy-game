<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Space Shooter</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<meta name="viewport"
content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
body {
  margin: 0;
  background: black;
  overflow: hidden;
  touch-action: none;
  font-family: Arial, sans-serif;
}
canvas {
  display: block;
  margin: 0 auto;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
/* ===== TELEGRAM ===== */
const tg = window.Telegram?.WebApp;
tg?.ready();
tg?.expand();

/* ===== CANVAS (RETINA FIX) ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const DPR = window.devicePixelRatio || 1;
const WIDTH = 360;
const HEIGHT = 640;

canvas.style.width = WIDTH + "px";
canvas.style.height = HEIGHT + "px";
canvas.width = WIDTH * DPR;
canvas.height = HEIGHT * DPR;
ctx.scale(DPR, DPR);

/* ===== GAME STATE ===== */
let gameOver = false;

/* ===== PLAYER ===== */
const player = {
  x: WIDTH / 2 - 20,
  y: HEIGHT - 80,
  w: 40,
  h: 40,
  hp: 3,
  maxHp: 3,
  targetX: WIDTH / 2 - 20,
  speed: 0.15,
  fireRate: 8,
  fireCooldown: 0
};

let bullets = [];
let enemies = [];
let coins = [];

/* ===== INPUT ===== */
canvas.addEventListener("touchmove", e => {
  const rect = canvas.getBoundingClientRect();
  player.targetX =
    e.touches[0].clientX - rect.left - player.w / 2;
});

/* ===== GAME LOOP ===== */
function loop() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  if (!gameOver) {
    update();
    draw();
  } else {
    drawGameOver();
  }

  requestAnimationFrame(loop);
}

/* ===== UPDATE ===== */
function update() {
  // smooth movement
  player.x += (player.targetX - player.x) * player.speed;
  player.x = Math.max(0, Math.min(WIDTH - player.w, player.x));

  autoShoot();
  updateBullets();
  updateEnemies();
  spawnEnemies();
}

/* ===== SHOOTING ===== */
function autoShoot() {
  if (player.fireCooldown-- > 0) return;
  bullets.push({
    x: player.x + player.w / 2 - 2,
    y: player.y,
    speed: 10
  });
  player.fireCooldown = player.fireRate;
}

/* ===== BULLETS ===== */
function updateBullets() {
  bullets.forEach((b, i) => {
    b.y -= b.speed;
    if (b.y < 0) bullets.splice(i, 1);
  });
}

/* ===== ENEMIES ===== */
function spawnEnemies() {
  if (Math.random() < 0.025) {
    const hp = Math.random() < 0.3 ? 5 : 3;
    enemies.push({
      x: Math.random() * (WIDTH - 40),
      y: -50,
      w: 40,
      h: 40,
      hp,
      maxHp: hp,
      speed: 2
    });
  }
}

function updateEnemies() {
  enemies.forEach((e, ei) => {
    e.y += e.speed;

    // collision with bullets
    bullets.forEach((b, bi) => {
      if (hit(b, e)) {
        bullets.splice(bi, 1);
        e.hp--;
        if (e.hp <= 0) enemies.splice(ei, 1);
      }
    });

    // collision with player
    if (rectHit(player, e)) {
      enemies.splice(ei, 1);
      player.hp--;
      if (player.hp <= 0) gameOver = true;
    }

    if (e.y > HEIGHT) enemies.splice(ei, 1);
  });
}

/* ===== DRAW ===== */
function draw() {
  // player
  ctx.fillStyle = "#00ffff";
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // bullets
  ctx.fillStyle = "yellow";
  bullets.forEach(b =>
    ctx.fillRect(b.x, b.y, 4, 10)
  );

  // enemies + HP
  enemies.forEach(e => {
    ctx.fillStyle = "red";
    ctx.fillRect(e.x, e.y, e.w, e.h);

    // HP bar
    ctx.fillStyle = "black";
    ctx.fillRect(e.x, e.y - 6, e.w, 4);
    ctx.fillStyle = "lime";
    ctx.fillRect(
      e.x,
      e.y - 6,
      (e.hp / e.maxHp) * e.w,
      4
    );
  });

  // UI
  ctx.fillStyle = "white";
  ctx.fillText("❤️ ".repeat(player.hp), 10, 20);
}

/* ===== GAME OVER ===== */
function drawGameOver() {
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = "white";
  ctx.font = "28px Arial";
  ctx.fillText("GAME OVER", 90, 300);
  ctx.font = "16px Arial";
  ctx.fillText("Tap to restart", 120, 340);
}

/* ===== RESTART ===== */
canvas.addEventListener("click", () => {
  if (gameOver) location.reload();
});

/* ===== COLLISION ===== */
function hit(b, e) {
  return (
    b.x > e.x &&
    b.x < e.x + e.w &&
    b.y > e.y &&
    b.y < e.y + e.h
  );
}

function rectHit(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

loop();
</script>
</body>
</html>

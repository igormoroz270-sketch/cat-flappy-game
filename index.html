<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cat Flappy Runner</title>

<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
  body {
    margin: 0;
    background: #87ceeb;
    overflow: hidden;
    touch-action: manipulation;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #87ceeb;
  }
</style>
</head>
<body>

<canvas id="game" width="360" height="640"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const tg = window.Telegram?.WebApp;
tg?.ready();
tg?.expand();

// ===== PLAYER =====
let cat = {
  x: 80,
  y: 300,
  size: 40,
  vel: 0
};

let gravity = 0.6;
let jump = -10;

// ===== GAME STATE =====
let score = 0;
let lives = 3;
let gameOver = false;
let scoreSent = false;

// ===== BOOST STATES =====
let shieldActive = false;
let shieldTimer = 0;

let x2Active = false;
let x2Timer = 0;

// ===== POINT =====
let point = {
  x: 360,
  y: Math.random() * 500 + 50,
  size: 20,
  speed: 3
};

// ===== BOOST ITEMS =====
let shieldItem = null;
let x2Item = null;

// ===== OBSTACLES =====
let obstacles = [];
let obstacleTimer = 0;

const obstacleGap = 150;
const obstacleWidth = 50;
const obstacleSpeed = 3;

// ===== INPUT =====
document.addEventListener("click", () => {
  if (!gameOver) cat.vel = jump;
  else location.reload();
});

// ===== GAME LOOP =====
function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Physics
  cat.vel += gravity;
  cat.y += cat.vel;

  // Draw cat
  ctx.fillStyle = "orange";
  ctx.fillRect(cat.x, cat.y, cat.size, cat.size);

  // Shield effect
  if (shieldActive) {
    ctx.strokeStyle = "cyan";
    ctx.lineWidth = 4;
    ctx.strokeRect(cat.x - 4, cat.y - 4, cat.size + 8, cat.size + 8);
    shieldTimer--;
    if (shieldTimer <= 0) shieldActive = false;
  }

  // x2 timer
  if (x2Active) {
    x2Timer--;
    if (x2Timer <= 0) x2Active = false;
  }

  // ===== POINT =====
  point.x -= point.speed;
  drawCircle(point.x, point.y, point.size / 2, "gold");

  if (point.x < -20) resetPoint();

  if (rectHit(cat, point)) {
    score += x2Active ? 2 : 1;
    resetPoint();
  }

  // ===== BOOST SPAWN =====
  spawnBoosts();

  // Draw boosts
  drawBoost(shieldItem, "cyan");
  drawBoost(x2Item, "purple");

  // Collect boosts
  collectBoosts();

  // ===== OBSTACLES =====
  obstacleTimer++;
  if (obstacleTimer > 120) {
    createObstacle();
    obstacleTimer = 0;
  }

  for (let i = obstacles.length - 1; i >= 0; i--) {
    let o = obstacles[i];
    o.x -= obstacleSpeed;

    ctx.fillStyle = "#228B22";
    ctx.fillRect(o.x, 0, obstacleWidth, o.top);
    ctx.fillRect(o.x, o.top + obstacleGap, obstacleWidth, canvas.height);

    if (
      rectCollision(cat, { x: o.x, y: 0, w: obstacleWidth, h: o.top }) ||
      rectCollision(cat, {
        x: o.x,
        y: o.top + obstacleGap,
        w: obstacleWidth,
        h: canvas.height
      })
    ) {
      hitObstacle();
    }

    if (o.x < -obstacleWidth) obstacles.splice(i, 1);
  }

  // ===== UI =====
  ctx.fillStyle = "#000";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 20, 40);
  ctx.fillText("Lives: " + lives, 20, 70);

  if (x2Active) ctx.fillText("x2 ACTIVE", 240, 40);
  if (shieldActive) ctx.fillText("SHIELD", 240, 70);

  // Borders
  if (cat.y > 600 || cat.y < 0) hitObstacle();

  if (!gameOver) requestAnimationFrame(loop);
}

// ===== FUNCTIONS =====
function hitObstacle() {
  if (shieldActive) return;

  lives--;
  shieldActive = true;
  shieldTimer = 60; // short invulnerability after hit
  cat.vel = -8;

  if (lives <= 0) endGame();
}

function spawnBoosts() {
  if (!shieldItem && Math.random() < 0.003) {
    shieldItem = createBoost();
  }
  if (!x2Item && Math.random() < 0.003) {
    x2Item = createBoost();
  }
}

function createBoost() {
  return {
    x: canvas.width,
    y: Math.random() * 500 + 50,
    size: 20,
    speed: 3
  };
}

function drawBoost(boost, color) {
  if (!boost) return;
  boost.x -= boost.speed;
  drawCircle(boost.x, boost.y, boost.size / 2, color);
  if (boost.x < -20) boost = null;
}

function collectBoosts() {
  if (shieldItem && rectHit(cat, shieldItem)) {
    shieldActive = true;
    shieldTimer = 180; // 3 seconds
    shieldItem = null;
  }

  if (x2Item && rectHit(cat, x2Item)) {
    x2Active = true;
    x2Timer = 300; // 5 seconds
    x2Item = null;
  }
}

function createObstacle() {
  let topHeight = Math.random() * 250 + 50;
  obstacles.push({ x: canvas.width, top: topHeight });
}

function resetPoint() {
  point.x = canvas.width;
  point.y = Math.random() * 500 + 50;
}

function rectCollision(a, b) {
  return (
    a.x < b.x + b.w &&
    a.x + a.size > b.x &&
    a.y < b.y + b.h &&
    a.y + a.size > b.y
  );
}

function rectHit(a, b) {
  return (
    a.x < b.x + b.size &&
    a.x + a.size > b.x &&
    a.y < b.y + b.size &&
    a.y + a.size > b.y
  );
}

function drawCircle(x, y, r, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fill();
}

function endGame() {
  gameOver = true;
  drawGameOver();
  sendScore();
}

function drawGameOver() {
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.font = "40px Arial";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", canvas.width / 2, 280);

  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, canvas.width / 2, 320);
  ctx.fillText("Tap to restart", canvas.width / 2, 360);
}

function sendScore() {
  if (tg && !scoreSent) {
    tg.sendData(JSON.stringify({ score }));
    scoreSent = true;
  }
}

loop();
</script>

</body>
</html>
